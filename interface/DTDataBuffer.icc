/*
 *  See header file for a description of this class.
 *
 *  $Date: 2006/02/28 17:28:55 $
 *  $Revision: 1.5 $
 *  \author Paolo Ronchese INFN Padova
 *
 */

//----------------------
// This Class' Header --
//----------------------
#include "CondFormats/DTObjects/interface/DTDataBuffer.h"

//-------------------------------
// Collaborating Class Headers --
//-------------------------------


//---------------
// C++ Headers --
//---------------


//-------------------
// Initializations --
//-------------------

template<class Key, class Content>
std::map<std::string,DTBufferTree<Key,Content>*>
DTDataBuffer<Key,Content>::bufferMap;

//----------------
// Constructors --
//----------------
template<class Key, class Content>
DTDataBuffer<Key,Content>::DTDataBuffer() {
}


//--------------
// Destructor --
//--------------
template<class Key, class Content>
DTDataBuffer<Key,Content>::~DTDataBuffer() {
}


template<class Key, class Content>
DTBufferTree<Key,Content>*
DTDataBuffer<Key,Content>::openBuffer( std::string& name ) {
  DTBufferTree<Key,Content>* ptr = 0;
  typename std::map<std::string,DTBufferTree<Key,Content>*>::iterator iter;
  if ( ( iter = bufferMap.find( name ) ) != bufferMap.end() )
       return iter->second;
  bufferMap.insert( std::pair<std::string,DTBufferTree<Key,Content>*>(
                    name, ptr = new DTBufferTree<Key,Content> ) );
  return ptr;
}


template<class Key, class Content>
DTBufferTree<Key,Content>*
DTDataBuffer<Key,Content>::findBuffer( std::string& name ) {
  if ( bufferMap.find( name ) == bufferMap.end() ) return 0;
  return bufferMap.find( name )->second;
}


template<class Key, class Content>
void
DTDataBuffer<Key,Content>::dropBuffer( std::string& name ) {
  DTBufferTree<Key,Content>* ptr = findBuffer( name );
  if ( ptr == 0 ) return;
  delete ptr;
  bufferMap.erase( name );
}


